package org.wahlzeit.model;

import java.sql.*;
import java.util.Objects;

import org.wahlzeit.services.*;

public class Location extends DataObject{

    //Using an id to differentiate between locations, as its easier than having the the combination of name and coordinate as primary key.
    private LocationId id = null;
    private String name;
    private Coordinate coordinate;

    public Location(LocationId id, String name, double x, double y, double z) {
        //Preconditions: The arguments not null, in theory we would also need to validate that the Id is valid, but that would be too much effort
        ContractEnforcerUtil.assertArgumentNonNull(id, name);
        this.id = id;
        this.name = name;
        incWriteCount();
        coordinate = new CartesianCoordinate(x, y, z);
        //Postconditions: None
        assertClassInvariants();
    }

    public Location(LocationId id, String name, Coordinate c) {
        //Preconditions: The arguments are not null, in theory we would need to validate that the Id is valid, but that would be too much effort
        ContractEnforcerUtil.assertArgumentNonNull(id, name, c);
        this.id = id;
        this.name = name;
        incWriteCount();
        coordinate = c;
        //Postconditions: None
        assertClassInvariants();
    }

    public Location(String name, double x, double y, double z) {
        //Preconditions: The argument name is not null
        ContractEnforcerUtil.assertArgumentNonNull(name);
        this.id = LocationId.getNextId();
        this.name = name;
        incWriteCount();
        coordinate = new CartesianCoordinate(x, y, z);
        //Postconditions: None
        assertClassInvariants();
    }

    public Location(String name, Coordinate c) {
        //Preconditions: The arguments are not null
        ContractEnforcerUtil.assertArgumentNonNull(name, c);
        this.id = LocationId.getNextId();
        this.name = name;
        incWriteCount();
        coordinate = c;
        //Postconditions: None
        assertClassInvariants();
    }

    public Location(ResultSet rset) throws SQLException{
        //Preconditions: The argument rset is not null, but this will be checked in readFrom
        readFrom(rset);
        //Postconditions: None
        assertClassInvariants();
    }

    public LocationId getId(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return id;
    }

    public String getName(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return name;
    }

    public Coordinate getCoordinate(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return coordinate;
    }

    public boolean isEqual(Location l){
        assertClassInvariants();
        //Preconditions: The argument l is not null
        ContractEnforcerUtil.assertArgumentNonNull(l);
        if(!name.equals(l.name) || !coordinate.isEqual(l.coordinate))return false;
        //Postconditions: None
        return true;
    }

    @Override
    public boolean equals(Object o) {
        assertClassInvariants();
        //Preconditions: Object must not be null, Object Class must match own Class, Class Invariants of the Object must hold
        if (o == null) {
            return false;
        }

        if (o.getClass() != this.getClass()) {
            return false;
        }

        Location compare = (Location) o;
        //Since compare is not generated by a method asserting the Class Invariants, the check is necessary here
        compare.assertClassInvariants();

        //Postconditions: None
        return isEqual(compare);
    }

    @Override
    public int hashCode(){
        assertClassInvariants();
        //Preconditions: None
        //Postconditions: None
        return Objects.hash(name, coordinate.hashCode(), id);
    }

    @Override
    public String getIdAsString() {
        assertClassInvariants();
        //Preconditions: None
        //Postconditions: None
        return String.valueOf(id.asInt());
    }

    @Override
    public void readFrom(ResultSet rset) throws SQLException {
        //ClassInvariants are not checked here, since we override the Object anyway
        //Preconditions: The argument rset is not null
        ContractEnforcerUtil.assertArgumentNonNull(rset);
        //Possible SQLException cannot be handled here, it could be logged with Syslog.logThrowable, but since the Photo Class doesnt do it I wont too
        id = LocationId.getIdFromInt(rset.getInt("id"));
        name = rset.getString("name");
        //Load as cartesian coordinate, since its saved as such
        coordinate = new CartesianCoordinate(rset.getDouble("x_coordinate"),
                rset.getDouble("y_coordinate"),
                rset.getDouble("z_coordinate"));
        //Postconditions: None
        assertClassInvariants();
    }

    @Override
    public void writeOn(ResultSet rset) throws SQLException {
        assertClassInvariants();
        //Preconditions: The argument rset is not null
        ContractEnforcerUtil.assertArgumentNonNull(rset);
        rset.updateInt("id", id.asInt());
        rset.updateString("name", name);
        //Save as cartesian coordinate
        CartesianCoordinate c =coordinate.asCartesianCoordinate();
        rset.updateDouble("x_coordinate", c.getX());
        rset.updateDouble("y_coordinate", c.getY());
        rset.updateDouble("z_coordinate", c.getZ());
        //Postconditions: We would need to check if the data is now present in the database,
        //but should we try to call the LocationManager to read the now added location from the database
        //it would just return it from the cache, and deleting the cache after every write operation is not reasonable
        assertClassInvariants();
    }

    @Override
    public void writeId(PreparedStatement stmt, int pos) throws SQLException {
        assertClassInvariants();
        //Preconditions: The argument stmt is not null
        ContractEnforcerUtil.assertArgumentNonNull(stmt);
        stmt.setInt(pos, id.asInt());
        //Postconditions: Same problems as in writeOn()
    }

    public void assertClassInvariants(){
        //In theory we could check if the ID is still unique, but i will assume that the ID system does not break
        //Also i would be a lot of effort to do so, slowing down the execution
        coordinate.assertClassInvariants();
    }
}