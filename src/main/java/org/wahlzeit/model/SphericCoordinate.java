package org.wahlzeit.model;

import com.sun.mail.util.logging.MailHandler;

import java.util.LinkedList;
import java.util.Objects;

//The conversion methods and the doGetCentralAngle method implement
//the subclass specific behavior used in the abstract superclass.
@PatternInstance(
        patternName = "Template Method",
        participants = {
                "ConcreteClass"
        }
)
@PatternInstance(
        patternName = "Value Object",
        participants = {
                "ValueObject"
        }
)
public class SphericCoordinate extends AbstractCoordinate{

    //This is protected and not private to enable access during tests
    protected static LinkedList<SphericCoordinate> coordList = new LinkedList<SphericCoordinate>();

    private final double phi; //Azimuth, longitude
    private final double theta; //Inclination, latitude
    private final double radius;

    public static SphericCoordinate getSphericCoordinate(double phi, double theta, double r){
        //Preconditions: None, all Coordinates are valid
        //Checking if Coordinate already present
        for (SphericCoordinate c:coordList) {
            //Comparison with epsilon
            if(Math.abs(c.phi - phi)<=epsilon && Math.abs(c.theta - theta)<=epsilon && Math.abs(c.radius - r)<=epsilon)return c;
        }
        //Coordinate not present, creating a new one
        return new SphericCoordinate(phi,theta,r);
    }

    //Expecting angle input in radians
    private SphericCoordinate(double phi, double theta, double r){
        //Preconditions: r >= 0
        if(r < 0){
            throw new IllegalArgumentException("Radius cannot be negative");
        }
        //Keeping Angles within [-2PI, 2PI]
        //This could be made a precondition, but its more convenient for both the developer and the user to just enforce it here
        //This also holds for the setter methods for the angles
        this.phi = phi%(Math.PI*2);
        this.theta = theta%(Math.PI*2);
        this.radius = r;
        //Postcondtions: None
        assertClassInvariants();
        //New Coordinate is added to the shared list
        coordList.add(this);
    }

    public double getPhi(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return phi;
    }

    public double getTheta(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return theta;
    }

    public double getRadius(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return radius;
    }

    public SphericCoordinate setPhi(double phi){
        assertClassInvariants();
        //Preconditions: None
        SphericCoordinate changedCoord = getSphericCoordinate(phi%(Math.PI*2), this.theta, this.radius);
        //Postconditions: Changed Coordinate needs to be valid
        changedCoord.assertClassInvariants();
        return changedCoord;
    }

    public SphericCoordinate setTheta(double theta){
        assertClassInvariants();
        //Preconditions: None
        SphericCoordinate changedCoord = getSphericCoordinate(this.phi, theta%(Math.PI*2), this.radius);
        //Postconditions: Changed Coordinate needs to be valid
        changedCoord.assertClassInvariants();
        return changedCoord;
    }

    public SphericCoordinate setRadius(double r){
        assertClassInvariants();
        //Preconditions: r >= 0
        if(r < 0){
            throw new IllegalArgumentException("Radius cannot be negative");
        }
        SphericCoordinate changedCoord = getSphericCoordinate(this.phi, this.theta, r);
        //Postconditions: Changed Coordinate needs to be valid
        changedCoord.assertClassInvariants();
        return changedCoord;
    }

    @Override
    public boolean equals(Object o) {
        assertClassInvariants();
        /*//Preconditions: Object must not be null, Object Class must match own Class, Class Invariants of the Object must hold
        if (o == null) {
            return false;
        }

        if (o.getClass() != this.getClass()) {
            return false;
        }

        SphericCoordinate compare = (SphericCoordinate) o;
        //Since compare is not generated by a method asserting the Class Invvariants, the check is necessary here
        compare.assertClassInvariants();

        //Postconditions: None
        return isEqual(compare);*/
        return this == o;
    }

    @Override
    public int hashCode(){
        assertClassInvariants();
        //Preconditions: None
        //Postconditions: None
        //return Objects.hash(phi, theta, radius);
        return super.hashCode();
    }

    @Override
    public Object clone(){
        return this;
    }

    @Override
    public CartesianCoordinate asCartesianCoordinate() {
        assertClassInvariants();
        //Preconditions: None
        //3x = r*sin(theta)*cos(phi)
        double x = Math.sin(theta) * Math.cos(phi) * radius;
        //y = r*sin(theta)*sin(phi)
        double y = Math.sin(theta) * Math.sin(phi) * radius;
        //z = r * cos(theta)
        double z = Math.cos(theta) * radius;
        CartesianCoordinate converted = CartesianCoordinate.getCartesianCoordinate(x,y,z);
        //Postconditions: None (Theoretically: New coordinate must be equal to the old coordinate)
        //HOWEVER: This leads to a Stackoverflow, as we cannot check if the new Coordinate is
        //Equal without calling a conversion method, which then again needs to make this assertion.
        //As such this postcondition is not asserted.
        return converted;
    }

    protected double doGetCentralAngle(SphericCoordinate c) {
        //Assertion of Class Invariants is not necessary here, as they are already checked in
        //the conversion methods in the call of getCentralAngle in AbstractCoordinate
        //Preconditions: None, check if argument is null is handled in getCentralAngle
        //Postconditions: None
        return Math.acos(Math.sin(c.theta)* Math.sin(this.theta) + Math.cos(c.theta) * Math.cos(this.theta) * Math.cos(Math.abs(c.phi - this.phi)));
    }

    @Override
    public SphericCoordinate asSphericCoordinate() {
        assertClassInvariants();
        //Preconditions: None
        //Postconditions: None
        return this;
    }

    //Since this is a shared value object, a simple "return this == c.asSphericCoordinate()"
    // would suffice, i left the method to preserve a way to check attribute equality
    @Override
    public boolean isEqual(Coordinate c) {
        assertClassInvariants();
        //Preconditions: None
        if(c == null) {
            return false;
        }
        SphericCoordinate other = c.asSphericCoordinate();
        if(Math.abs(other.phi - this.phi)>epsilon || Math.abs(other.theta - this.theta)>epsilon || Math.abs(other.radius - this.radius)>epsilon)return false;
        //Postconditions: None
        return true;
    }

    //The Constructor and setter methods should already prevent a violation of the class invariant
    @Override
    public void assertClassInvariants() {
        //Invariant: radius >= 0
        assert this.radius >= 0;
        //Invariant: -2PI <= theta <= 2PI
        assert Math.abs(theta) <= 2*Math.PI;
        //Invariant: -2PI <= theta <= 2PI
        assert Math.abs(phi) <= 2*Math.PI;
    }
}
