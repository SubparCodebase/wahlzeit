package org.wahlzeit.model;

import com.sun.mail.util.logging.MailHandler;

import java.util.Objects;

public class SphericCoordinate extends AbstractCoordinate{

    private double phi; //Azimuth, longitude
    private double theta; //Inclination, latitude
    private double radius;

    //Expecting angle input in radians
    public SphericCoordinate(double phi, double theta, double r){
        //Preconditions: r >= 0
        if(r < 0){
            throw new IllegalArgumentException("Radius cannot be negative");
        }
        //Keeping Angles within [-2PI, 2PI]
        //This could be made a precondition, but its more convenient for both the developer and the user to just enforce it here
        //This also holds for the setter methods for the angles
        this.phi = phi%(Math.PI*2);
        this.theta = theta%(Math.PI*2);
        this.radius = r;
        //Postcondtions: None
        assertClassInvariants();
    }

    public double getPhi(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return phi;
    }

    public double getTheta(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return theta;
    }

    public double getRadius(){
        //Preconditions: None
        //Postconditions: None
        assertClassInvariants();
        return radius;
    }

    public void setPhi(double phi){
        assertClassInvariants();
        //Preconditions: None
        this.phi = phi%(Math.PI*2);
        //Postconditions: None
        assertClassInvariants();
    }

    public void setTheta(double theta){
        assertClassInvariants();
        //Preconditions: None
        this.theta = theta%(Math.PI*2);
        //Postconditions: None
        assertClassInvariants();
    }

    public void setRadius(double r){
        assertClassInvariants();
        //Preconditions: r >= 0
        if(r < 0){
            throw new IllegalArgumentException("Radius cannot be negative");
        }
        this.radius = r;
        //Postconditions: None
        assertClassInvariants();
    }

    @Override
    public boolean equals(Object o) {
        assertClassInvariants();
        //Preconditions: Object must not be null, Object Class must match own Class, Class Invariants of the Object must hold
        if (o == null) {
            return false;
        }

        if (o.getClass() != this.getClass()) {
            return false;
        }

        SphericCoordinate compare = (SphericCoordinate) o;
        //Since compare is not generated by a method asserting the Class Invvariants, the check is necessary here
        compare.assertClassInvariants();

        //Postconditions: None
        return isEqual(compare);
    }

    @Override
    public int hashCode(){
        assertClassInvariants();
        //Preconditions: None
        //Postconditions: None
        return Objects.hash(phi, theta, radius);
    }

    @Override
    public CartesianCoordinate asCartesianCoordinate() {
        assertClassInvariants();
        //Preconditions: None
        //3x = r*sin(theta)*cos(phi)
        double x = Math.sin(theta) * Math.cos(phi) * radius;
        //y = r*sin(theta)*sin(phi)
        double y = Math.sin(theta) * Math.sin(phi) * radius;
        //z = r * cos(theta)
        double z = Math.cos(theta) * radius;
        CartesianCoordinate converted = new CartesianCoordinate(x,y,z);
        //Postconditions: None (Theoretically: New coordinate must be equal to the old coordinate)
        //HOWEVER: This leads to a Stackoverflow, as we cannot check if the new Coordinate is
        //Equal without calling a conversion method, which then again needs to make this assertion.
        //As such this postcondition is not asserted.
        return converted;
    }

    protected double doGetCentralAngle(SphericCoordinate c) {
        //Assertion of Class Invariants is not necessary here, as they are already checked in
        //the conversion methods in the call of getCentralAngle in AbstractCoordinate
        //Preconditions: None, check if argument is null is handled in getCentralAngle
        //Postconditions: None
        return Math.acos(Math.sin(c.theta)* Math.sin(this.theta) + Math.cos(c.theta) * Math.cos(this.theta) * Math.cos(Math.abs(c.phi - this.phi)));
    }

    @Override
    public SphericCoordinate asSphericCoordinate() {
        assertClassInvariants();
        //Preconditions: None
        //Postconditions: None
        return this;
    }

    @Override
    public boolean isEqual(Coordinate c) {
        assertClassInvariants();
        //Preconditions: None
        if(c == null) {
            return false;
        }
        SphericCoordinate other = c.asSphericCoordinate();
        if(Math.abs(other.phi - this.phi)>epsilon || Math.abs(other.theta - this.theta)>epsilon || Math.abs(other.radius - this.radius)>epsilon)return false;
        //Postconditions: None
        return true;
    }

    //The Constructor and setter methods should already prevent a violation of the class invariant
    @Override
    public void assertClassInvariants() {
        //Invariant: radius >= 0
        assert this.radius >= 0;
        //Invariant: -2PI <= theta <= 2PI
        assert Math.abs(theta) <= 2*Math.PI;
        //Invariant: -2PI <= theta <= 2PI
        assert Math.abs(phi) <= 2*Math.PI;
    }
}
